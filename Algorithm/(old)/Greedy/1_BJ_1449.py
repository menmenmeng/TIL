'''
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.

파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.

항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.

물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.


4 2
1 2 100 101

2

4 3
1 2 3 4

2

3 1
3 2 1

3
'''
# 전략 : 물이 새는 곳들의 각각의 위치 차이를 리스트로 만든 다음.
# 테이프 길이랑 비교해서 .. 계산해보기

# 내가 쓴 답.
# 앞에서부터 계속해서 테이프를 붙여 가면서, 새는 부분이 나오면 기존 테이프로 덮고, 그렇지 않으면 기존 테이프가 아닌 새로운 테이프를 사용한다.
# "앞에서부터 붙인다"의 기본 가정 --> 이걸 어떻게 증명할 수 있을까?
# "앞에서부터 붙인다"를 어떻게 구현할까? 앞에서부터 붙인다를 알고 나면, 이를 구현하기는 쉽다.
N, L = map(int, input().split())
leaks = list(map(int, input().split()))
leaks.sort()
res = 0

p = leaks[0]
for i in range(N):
    leaks[i] -= p
    if leaks[i] >= L:
        res += 1
        p += leaks[i]
res += 1

print(res)


# 다른 사람 답.
# 시작점이 leak의 가장 첫 구간 - 0.5이며
# 1씩 더해 가면서, leak이 있는지 확인하고 있다면 기존걸로 덮고, 그러기엔 테이프가 짧다면 새로운 테이프를 사용하게 함.
from sys import stdin

N, L = map(int, stdin.readline().split())
B = list(map(int, stdin.readline().split()))
B.sort() 

cnt = 1
start = B[0] - 0.5 # 훨씬 더 직관적.. 이런 식으로 직관적으로 생각해라.

for i in range(1, len(B)):
    if start + L >= B[i] + 0.5:
        continue
    else:
        start = B[i] - 0.5
        cnt += 1
print(cnt)

'''
증명
x, x+k1, x+k2 라는 3개의 leak을 생각해보자.
얘네들의 테이프 붙이는 방법은.
-- -- --
----- --
-- -----
--------
이렇게 뿐이죠?
여기에 오른쪽에 하나가 더 들어왔다 쳐봐.
x, x+k1, x+k2, x+k3
k3-k2가 얼마냐에 관계없이.
위의 경우에서 x+k3을 커버하려면.
-- -- -- --
-- -- -----
----- -- --
----- -----
-- ----- --
-- --------
-------- --
-----------

앞에서만 붙이면 이렇게 하면 되죠.
--> 4개를 붙이는 모든 경우의 수가 됨.
그래서 그냥 앞에서부터 붙여도 된다는 거
이거는 4개에서 시작해도, 5개에서 시작해도... 항상 똑같다. 모든 경우의 수를 만들 수 있다는 거임
결과적으로? 앞에서부터 붙여도 최적의 수를 무조건 찾을 수 있다.
'''